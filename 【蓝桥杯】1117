参考链接 https://blog.dotcpp.com/a/56751

#include<stdio.h>
int main()
{
  int N,K,i,res_0,res_1;//res_1代表最高位非0  res_0代表最高位为0的结果 
  while(scanf("%d%d",&N,&K)!=EOF){
      res_1=K-1,res_0=1;//如果只有一位时 K进制首位为1的可以填的为K-1个数去掉为0 
      for(i=2;i<=N;i++){ 
      int last_res_1=res_1;//暂存 
      res_1=(K-1)*(res_1+res_0);//如果高位为1 则结果为上一次结果为1和为0的数的个数 
      res_0=last_res_1; //如果高位为0 则结果为上一次结果为1的数的个数 
      }
      printf("%d\n",res_1);
   }
    return 0;
}

 假设是让你求 1位 K 进制的满足条件的数，那么满足条件的数则有 1，2，3.....K-1 一共K-1个数对吧，我们记作 res_1=K-1,那么不满足条件的数 只有 0 ，一共1个数 ，我们记作res_0=1。
 
 假设是让你求 2位 K 进制的满足条件的数，那么先考虑首位（也就是第2位），可以填的数为除去0的其他数，有 1，2，3.....K-1 一共K-1个数对吧，
 而这第二位可以填的数 可以和第一位的所有数搭配，以1为例，有 11，12，13,.....1(K-1),还有在第一位不满足条件的 0 搭配 10，也是满足条件的数，
 所以2位K进制满足条件的数res_1=（K-1）*(K-1+1),即 res_1=(K-1)*（res_1+res_0）,对吧，
 再来看不满足条件的数 即 首位为0的 有 01，02，03.....0（K-1）,一共有K-1个也就是res_0=K-1,即 res_0=res_1(上一个)。
 第一位满足条件的数res_1对吧,因为不能连0 ，虽然00也是不满足，但是 00这种情况是绝对不满足，而首位不满足的情况是相对不满足，绝对和相对 懂吧。

 那么继续，假设是让你求 3位 K 进制的满足条件的数，同样先考虑首位（也就是第3位），可以填的数为除去0的其他数，有 1，2，3.....K-1 一共K-1个数对吧，
 而这第3位可以填的数 可以和2位K进制满足条件和（相对）不满足条件的数搭配，即 res_1=（K-1）*[(K-1)*(K-1+1)+(K-1)],即 res_1=(K-1)*(res_1+res_0),
 不满足条件的数则是可以和2位K进制满足条件的数搭配，res_0=（k-1）*(K-1+1),即res_0=res_1。

后面的位数就以此类推
